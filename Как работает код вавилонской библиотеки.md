# Базовые концепции

1. **Должен быть поиск по адресу**
2. **Должен быть поиск по контенту**
3. **Генерация случайных адресов**
4. **Генерация заголовков**
5. **Поиск по всем возможным книгам в библиотеке**
6. **Вычисление количества результатов поиска**

# Поиск по адресу

**На вход дается:**
- HEX-адрес (т.е. адрес комнаты)
- Номер стены
- Номер полки
- Номер книги
- Номер страницы

1. Вычисляется *адрес конкретного объекта в секции библиотеки* путем складывания *строковых* значений страницы, книги, полки и стены. Причем если *страница* содержит меньше чем 3 цифры, то в начало добавляется нуль для соответствию размеру в 3 цифры. Тоже самое происходит и с номером книги, но в таком случае размер - 2 цифры

$$
A = int(P + B + S + W)
$$

2. Затем вычисляется *сид* для книги. Он должен быть уникальным, и поэтому его формула довольно сложна. Она вычисляется как:

$$
S = int(hexBase) - libCoodinate \cdot charsetLen^{maxSimbols \cdot maxLines} 
$$

- *hexBase* — HEX часть данного адреса
- *libCoordinate* — Координата секции библиотеки из пункта *1*
- *charsetLen* — Количество символов в наборе для генерации текстов
- *maxSimbols* — Максимальное количество символов на строку
- *maxLines* — Максимальное количество строк на странице

3. После сида вычисляется сам адрес. Для этого вначале вычисляется «ссылка на сид» путем конвертации сида в 36-значную систему счисления, где знаки это сумма английского алфавита и 10 цифр. И после адрес вычисляется как

$$
A = base(S, charsetLen)
$$
4. Затем обрабатываются случаи, когда количество символов меньше чем максимальное количество символов на страницу. Для этого задается сид для генератора псевдослучайных чисел, и после этого начинается цикл, что заполняет свободные места в тексте, путем добавления случайной буквы из буквенного набора

5. Также обрабатываются случаи, когда количество символов больше, чем максимальное количество символов на страницу. В таком случае превышающие лимит буквы отрезаются от результата

# Поиск по контенту

> *Важная оговорка: данная функция не ищет текст по всей библиотеке, а только в конкретном месте*


**На вход дается:**
- Текст для поиска
- Координата секции в библиотеке

1. Если длинна текста меньше максимальной, то заполняем его случайным образом, основываясь на координате секции (таким же образом, как и в случае с поиском по адресу). 
2. Вычисляем HEX-адрес, т.е. численное представление текста:
	1. Цикл проходится по всему тексту реверсивно, вычисляя буквенное значение и прибавляет его к числовому значению, после некоторых математических операций
	2. Буквенное значение вычисляется путем простого алгоритма:
		1. Если буква из текста содержится в ASCII, то буквенное значение вычисляется как: числовой эквивалент буквы минус 97 (код символа «a» в таблице ASCII) $$C = (int)ch - 97$$
		2. Иначе буквенное значение равно индексу этого знака в буквенном наборе $$C = i$$
	3. К числовому значению прибавляется буквенное значение умноженное на длину буквенного набора в степени *индекс буквы из изначального текста (т.е. итерация цикла)* 
$$
S = S + C \cdot charsetLen^{i}
$$
3. Адрес вычисляется как координата секции библиотеки умноженная на умноженное на длину буквенного набора в степени максимального количества символов на страницу плюс численное представление текста $$A = libCoord \cdot charsetLen^{maxCharsetLen} + S$$
4. После адрес переводится в 36-значную систему счисления $$A = base(A, 36)$$

# Заголовки у книг

???

# Поиск по всем книгам в библиотеке

???
# Генерация случайного адреса

???

# Вычисление количества результатов поиска

???

# Главный принцип работы
На самом деле код не именно *ищет* заданный текст во всей вавилонской библиотеке, а генерирует либо адрес, основываясь на контексте, что вы дали этому алгоритму, либо генерирует текст, соответствующий адресу.